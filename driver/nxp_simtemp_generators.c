#include <linux/ktime.h>
#include <linux/random.h>

#include "nxp_simtemp.h"
#include "nxp_simtemp_generators.h"

/* Value noise for the normal generator courtesy of Gemini AI, with fine-tuning by me */
/* See docs/AI_NOTES.md for prompt details */

/********************* START OF AUTOGENERATED SECTION *************************/
/* Generated by noise_table_gen.py. DO NOT EDIT MANUALLY */
/* Generated on: 2025-11-06 01:43:08 */
#define NOISE_TABLE_SIZE 256
#define NOISE_VALUE_EXP 24

const s32 VALUE_TABLE[NOISE_TABLE_SIZE] = {
    453194,     457587,     484984,     549775,     658194,     809674,     998209,     1213714,
    1443383,     1673052,     1888557,     2077092,     2228572,     2336991,     2401782,     2429179,
    2433572,     2453599,     2578496,     2873871,     3368138,     4058713,     4918217,     5900672,
    6947702,     7994731,     8977186,     9836690,     10527265,     11021532,     11316907,     11441804,
    11461831,     11455427,     11415486,     11321030,     11162971,     10942135,     10667278,     10353103,
    10018278,     9683454,     9369279,     9094422,     8873586,     8715527,     8621071,     8581130,
    8574726,     8582446,     8630589,     8744446,     8934969,     9201162,     9532471,     9911174,
    10314768,     10718362,     11097065,     11428374,     11694567,     11885090,     11998947,     12047090,
    12054810,     12032592,     11894033,     11566347,     11018014,     10251898,     9298374,     8208451,
    7046888,     5885325,     4795402,     3841878,     3075762,     2527429,     2199743,     2061184,
    2038966,     2046992,     2097044,     2215415,     2413491,     2690238,     3034682,     3428399,
    3847994,     4267590,     4661307,     5005751,     5282498,     5480574,     5598945,     5648997,
    5657023,     5670134,     5751902,     5945279,     6268867,     6720974,     7283676,     7926872,
    8612344,     9297817,     9941013,     10503715,     10955822,     11279410,     11472787,     11554555,
    11567666,     11544646,     11401085,     11061569,     10493440,     9699666,     8711719,     7582448,
    6378951,     5175454,     4046183,     3058236,     2264462,     1696333,     1356817,     1213256,
    1190236,     1210125,     1334160,     1627497,     2118353,     2804164,     3657737,     4633413,
    5673218,     6713023,     7688699,     8542272,     9228083,     9718939,     10012276,     10136311,
    10156200,     10149020,     10104240,     9998338,     9821127,     9573532,     9265371,     8913128,
    8537732,     8162336,     7810093,     7501932,     7254337,     7077126,     6971224,     6926444,
    6919264,     6918575,     6914275,     6904107,     6887093,     6863321,     6833734,     6799915,
    6763872,     6727830,     6694011,     6664424,     6640652,     6623638,     6613470,     6609170,
    6608481,     6605294,     6585418,     6538412,     6459754,     6349856,     6213075,     6056727,
    5890103,     5723479,     5567131,     5430350,     5320452,     5241794,     5194788,     5174912,
    5171725,     5186468,     5278410,     5495848,     5859700,     6368062,     7000781,     7724009,
    8494773,     9265537,     9988765,     10621484,     11129846,     11493698,     11711136,     11803078,
    11817821,     11799262,     11683517,     11409788,     10951742,     10311774,     9515256,     8604797,
    7634496,     6664195,     5753736,     4957218,     4317250,     3859204,     3585475,     3469730,
    3451171,     3475290,     3625707,     3981435,     4576695,     5408373,     6443497,     7626695,
    8887662,     10148629,     11331827,     12366951,     13198629,     13793889,     14149617,     14300034,
    14324153,     14293384,     14101493,     13647680,     12888292,     11827297,     10506761,     8997324,
    7388674,     5780023,     4270586,     2950050,     1889055,     1129667,     675854,     483963
};
/********************** END OF AUTOGENERATED SECTION **************************/
#define NOISE_TABLE_MASK (NOISE_TABLE_SIZE - 1)
struct noise_state {
    u64 current_position;
    u32 x_factor;
};

struct noise_state state = {
        .current_position = 0,
        .x_factor = 0x7000FFFF,
};

/**
 * s32_lerp_scaled - Linearly interpolate between signed start and stop values 
 * using a factor t scaled by tmax.
 * @start: The signed start value (A).
 * @stop: The signed end value (B).
 * @tmax: The maximum value t can take (u32, defines the scale factor).
 * @t: The current interpolation factor (u32, 0 <= t <= tmax).
 *
 * The calculation is equivalent to: (start * (tmax - t) + stop * t) / tmax.
 * Uses 64-bit intermediate storage (s64) to safely handle signed multiplication 
 * and prevent overflow.
 *
 * Returns: The interpolated s32 value.
 * Courtesy of Gemini AI
 */
static inline s32 lerp(s32 start, s32 stop, u32 tmax, u32 t)
{
    s64 a_term, b_term, result;
    u32 t_inv; // Represents (tmax - t)

    // Handle edge cases for efficiency
    if (t == 0 || tmax == 0)
        return start;

    if (t >= tmax)
        return stop;

    // 1. Calculate the inverse factor: (tmax - t)
    t_inv = tmax - t;

    // 2. Calculate the start term: start * (tmax - t)
    // Cast BOTH 'start' (s32) and 't_inv' (u32) to s64 before multiplication.
    // Casting 't_inv' to s64 ensures the entire multiplication result is signed.
    a_term = (s64)start * (s64)t_inv;

    // 3. Calculate the stop term: stop * t
    b_term = (s64)stop * (s64)t;

    // 4. Sum the terms
    // The sum is guaranteed to fit within s64 (approx. 2*2^63 max).
    result = a_term + b_term;

    // 5. Divide by tmax (restores the s32 integer value)
    // The division must be performed using the signed 64-bit result.
    // The divisor tmax (u32) is safely promoted to s64 for the division.
    return (s32)(result / tmax);
}

static s32 normal_generator(void)
{
        const s32 result_range = MAX_TEMP - MIN_TEMP;

        u32 x_int;
        u32 x_frac;
        s32 val0, val1;
        s32 scaled_result;

        // 1. Calculate the current fractional and integer parts of the position.
        // The current_position is an accumulating counter.
        state.current_position += state.x_factor;

        // x_int: Integer part (used for table indexing).
        // The current_position is treated as Q32.32 (32 integer bits, 32 fractional bits).
        x_int = (state.current_position >> 32); 

        // x_frac: Fractional part (used for interpolation factor t).
        x_frac = (u32)state.current_position; 

        // 2. Determine the two surrounding integer points (i0, i1)
        // The base index i0 is hashed with the random seed to break the pattern.
        u32 i0 = (x_int) & NOISE_TABLE_MASK;
        u32 i1 = (i0 + 1) & NOISE_TABLE_MASK;

        // 3. Look up the values at the surrounding points.
        val0 = VALUE_TABLE[i0];
        val1 = VALUE_TABLE[i1];

        // 4. Interpolate between the two values.
        // The LERP function uses x_frac as 't' and the max u32 value as 'tmax' (2^32-1)
        // The LERP output is in the range of the VALUE_TABLE [0, 2 ^ NOISE_VALUE_EXP].
        scaled_result = lerp(val0, val1, UINT_MAX, x_frac); // UINT_MAX is 2^32 - 1

        // 5. Final Rescaling and Shifting to [MIN_TEMP, MAX_TEMP]
        // The interpolation factor used in the scaling is 2 ^ NOISE_VALUE_EXP.
        // Result = (scaled_result >> NOISE_VALUE_EXP) * result_range + MIN_TEMP
        s64 final_val = (s64)scaled_result * result_range;

        // Perform the division and add the minimum offset
        final_val = (s64)((u64)final_val >> NOISE_VALUE_EXP);

        // 6. Return the clamped result
        return (s32)final_val + MIN_TEMP;
}

static s32 noisy_generator(void)
{
        /* Get random in the supported range, + 1 for inclusive ceil */
        u32 rand = get_random_u32_below(MAX_TEMP - MIN_TEMP + 1);
        return (s32)((s64)rand + (s64)MIN_TEMP);
}

static s32 ramp_generator(void)
{
        static u32 elapsed_time = 0;

        elapsed_time += sampling_ms;
        if (elapsed_time >= ramp_period_ms) {
                elapsed_time = 0;
        }

        return lerp(ramp_min, ramp_max, ramp_period_ms, elapsed_time);
}

void get_temp_sample(struct simtemp_sample *sample)
{
        s32 temp;
        
        switch (mode)
        {
        case simtemp_mode_normal:
                temp = normal_generator();
                break;
        case simtemp_mode_noisy:
                temp = noisy_generator();
                break;
        case simtemp_mode_ramp:
                temp = ramp_generator();
                break;
        default:
                /* should never come here */
                temp = 0;
                break;
        }

        sample->timestamp = ktime_to_ns(ktime_get_boottime());
        sample->temp_mC = temp;
}
