# Courtesy of Gemini AI

import numpy as np
import math
import sys
from datetime import datetime

# --- CONFIGURATION (Must match kernel definitions) ---

# The size of the final smooth noise table (must be power of 2)
NOISE_TABLE_SIZE = 256
# The number of random control points (more points = more detail)
INTERPOLATION_POINTS = 16
# The exponent for the max magnitude of the gradients (2 ** NOISE_VALUE_EXP)
NOISE_VALUE_EXP = 24

# --- CORE SMOOTHING FUNCTION ---

def smootherstep(t):
    """Perlin's smootherstep function: 6t^5 - 15t^4 + 10t^3"""
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0)

# --- PRECOMPUTATION ---

def precompute_value_table():
    # 1. Initialize random gradient points
    # Seed based on current time for a unique table every run
    np.random.seed(int(datetime.now().timestamp())) 
    
    # Generate random s32 values in the range [0, (2 ** NOISE_VALUE_EXP)]
    RANDOM_GRADIENTS = np.random.randint(
        0, (2 ** NOISE_VALUE_EXP) + 1, size=INTERPOLATION_POINTS, dtype=np.int32
    )

    VALUE_TABLE = np.zeros(NOISE_TABLE_SIZE, dtype=np.int32)
    step_size = NOISE_TABLE_SIZE / INTERPOLATION_POINTS

    for i in range(NOISE_TABLE_SIZE):
        # Current logical position (0.0 to INTERPOLATION_POINTS)
        current_pos = i / step_size
        
        # i0, i1: The surrounding integer control point indices
        i0 = math.floor(current_pos)
        i1 = (i0 + 1) % INTERPOLATION_POINTS
        
        # t: The fractional part (alpha)
        t = current_pos - i0
        
        # Smooth the interpolation factor t
        smooth_t = smootherstep(t)

        # Get the random values at the control points
        v0 = RANDOM_GRADIENTS[i0]
        v1 = RANDOM_GRADIENTS[i1]

        # Standard LERP: V0 * (1 - t) + V1 * t
        interpolated_value = v0 * (1.0 - smooth_t) + v1 * smooth_t

        # Convert the result to the final signed integer and store
        VALUE_TABLE[i] = np.int32(round(interpolated_value))
        
    return VALUE_TABLE

# --- OUTPUT GENERATION ---

def output_c_code(value_table):
    """Prints the table as a C array definition."""
    
    output = []
    output.append("/* Generated by Python precomputation script. DO NOT EDIT MANUALLY */")
    output.append(f"/* Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} */")
    output.append("#include <linux/types.h>")
    output.append(f"#define NOISE_TABLE_SIZE {NOISE_TABLE_SIZE}")
    output.append(f"#define NOISE_VALUE_EXP {NOISE_VALUE_EXP}")
    output.append("")
    output.append("const s32 VALUE_TABLE[NOISE_TABLE_SIZE] = {")
    
    line = []
    for i, val in enumerate(value_table):
        line.append(f"    {val}")
        if (i + 1) % 8 == 0 or i == len(value_table) - 1:
            # Print and reset the line
            output.append(", ".join(line) + ("," if i < len(value_table) - 1 else ""))
            line = []
    
    output.append("};")
    
    return "\n".join(output)

# --- EXECUTION ---

if __name__ == "__main__":
    try:
        table = precompute_value_table()
        print(output_c_code(table))
    except ImportError:
        print("Error: NumPy is required to run this script.", file=sys.stderr)
        print("Please install it: pip install numpy", file=sys.stderr)
